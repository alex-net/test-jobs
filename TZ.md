Выполнять задание с использованием фреймворка Yii2.

Написать приложение с авторизацией\регистрацией пользователей.

Создать несколько таблиц и заполнить тестовыми данными.

При авторизации вывести навигационную панель с кнопками, по нажатию на которые выводятся данные из созданных таблиц.

Учесть, что у пользователей должны быть роли - количество ролей неважно, однако важно, чтобы была роль Админ.

Если пользователь авторизован как Админ, то вывести дополнительно в навигационную панель таблицу с пользователями.

<u>Дополнительно.</u>

Для пользователя Админ реализовать добавление\редактирование данных.

Два варианта выполнения:
A) простой - без особых условий, полная свобода выбора реализации;
B) усложненный - выполнить задание с использованием динамических баз данных,
которые создаются под каждого пользователя с определенным набором таблиц.

*решение:* В качестве реализации был выбран базовая сборка для тестовых заданий. Пользлватели были веренесены в базу данных. Был поднят RBAC на основе ролей. Кроме роли админа взято ещё 2 роли, которые назначаются пользователя при регистрации произвольным образом. Также после регистрации кадому пользователю назначается произвольный контент в виде элементов двух сущностей (книги и авторы - взято из следующего задания). После залогинивания в меню сайта появляются две ссылки на списки этих сущностей. Обычному пользователю доступны только списки, админ может редактировать каждый элемент. Админу также доступен список всех зарегистрированных пользователей, так же количество книг и авторов, которые прикреплены к этим пользователям. По реализации пошли по варианту B.

----

**Задание 2**

Написать 2 варианта SQL запроса с использованием JOIN и вложенным запросом. Описать в чем особенность использования JOIN
    book (id, title)
    author (id, full_name)
    book_to_author (id, book_id, author_id)

Вывести список: Название книги, Количество авторов книги, Имена авторов книги через “,”
Упорядочить по возрастанию количества авторов.

*решение:*
Запрос с использованием join-ов из PostgreSQL выглядит примерно так:
`` select substr(b.title,0, 10) as book, count(bta.id) as co, string_agg(substr( a.full_name, 0, 5),
', ') as authors from book b left join book_to_author bta on bta.book_id= b.id left join author a on a.id = bta.author_id  group by b.id order by co desc   limit 20; ``
В данном случае вызовы *substr* и применение *limit 20* связано с ограничением выборки. В реализации с подзапросами это бы выглядело страшнее, потому как подзапросы с гуппировко находились вместо определения количества и вместо авторов (было бы два подзапроса с группировкой и с where по номеру книги). Особенностью использования JOIN в этом случае является выполнение одного запроса,  вместо хз сколько на основе подзапросов, что значительно напрягало бы базу.

 ---

**Задание 3**

Задача. Есть: 6 котлет; 1 сковородка.
На сковородке помещается только 4 котлеты. Прожаривать котлеты нужно по 1 минуте с каждой стороны.
Сколько нужно времени, чтобы пожарить 6 котлет?

*решение:* рассуждаем = Оптимальным вариантом жарки котлет в этом случае является полностью заполненная сковорода. Поэтому можно расписать каждую минуту:
1. жарим 4 котлеты с одной стороны
1. жарим 2 котлеты оставшиеся с одной сторны и 2 котлеты (уже пожаренные с одной стороны)  до полной готовки.
1. жарим остальные 4. со второй стороны.

ps. приятного аппетита (уложились в 3 минуты)

